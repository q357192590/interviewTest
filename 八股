一、HashMap线程安全性问题
    1 多线程的put可能导致元素的丢失
        同时put的覆盖。
    2 put和get并发时，可能导致get为null
        线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。
    3 JDK7中HashMap并发put会造成循环链表，导致get时出现死循环
        发生在多线程并发resize的情况下。
二、HashMap 与 ConcurrentHashMap 的实现原理是怎样的？ConcurrentHashMap 是如何保证线程安全的？
    1 数组链表(1.7)红黑树(1.8) / 数组链表(1.7)红黑树(1.8)
    2 不建议并发 / Segment(1.7)Node(1.8)
    3 对ConcurrentHashMap是如何解决HashMap并发问题这一疑问进行简要说明。
        首先new一个新的hash表(nextTable)出来，大小是原来的2倍。后面的rehash都是针对这个新的hash表操作，不涉及原hash表(table)。
        然后会对原hash表(table)中的每个链表进行rehash，此时会尝试获取头节点的锁。这一步就保证了在rehash的过程中不能对这个链表执行put操作。
        3 通过sizeCtl控制，使扩容过程中不会new出多个新hash表来。
        2 最后，将所有键值对重新rehash到新表(nextTable)中后，用nextTable将table替换。这就避免了HashMap中get和扩容并发时，可能get到null的问题。
        在整个过程中，共享变量的存储和读取全部通过volatile或CAS的方式，保证了线程安全。
        1 put的时候加锁。
三、volatile 关键字解决了什么问题，它的实现原理是什么？
    可见性、有序性。

    volatile可见性的实现就是借助了CPU的lock指令，通过在写volatile的机器指令前加上lock前缀，使写volatile具有以下两个原则：
    写volatile时处理器会将缓存写回到主内存。
    一个处理器的缓存写回到内存会导致其他处理器的缓存失效。

    禁止指令重排序又是如何实现的呢？答案是加内存屏障。JMM为volatile加内存屏障有以下4种情况：
    在每个volatile写操作的前面插入一个StoreStore屏障，防止写volatile与后面的写操作重排序。
    在每个volatile写操作的后面插入一个StoreLoad屏障，防止写volatile与后面的读操作重排序。
    在每个volatile读操作的后面插入一个LoadLoad屏障，防止读volatile与后面的读操作重排序。
    在每个volatile读操作的后面插入一个LoadStore屏障，防止读volatile与后面的写操作重排序。

四、Synchronized 关键字底层是如何实现的？它与 Lock 相比优缺点分别是什么？

    synchronized同步代码块的时候通过加入字节码monitorenter和monitorexit指令来实现monitor的获取和释放， 也就是需要JVM通过字节码显式的去获取和释放monitor实现同步，
    而synchronized同步方法的时候，没有使用这两个指令， 而是检查方法的ACC_SYNCHRONIZED标志是否被设置，如果设置了则线程需要先去获取monitor，执行完毕了线程再释放monitor，也就是不需要JVM去显式的实现。
    这两个同步方式实际都是通过获取monitor和释放monitor来实现同步的，而monitor的实现依赖于底层操作系统的mutex互斥原语， 而操作系统实现线程之间的切换的时候需要从用户态转到内核态，这个转成过程开销比较大。

    1、原始构成
        JVM层面/api层面
    2、使用方法
        手动释放锁/自动释放
    3、等待是否可中断
        不可中断/可中断
            中断方法：设置超时方法tryLock()、代码块中放lockInterruptibly()，调用interrupt()。
    4、加锁是否公平
        非公平/非公平，可实现公平
    5、绑定多个条件Condition
        达咩/可用Condition精确唤醒

五、Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？
    引用计数算法：可能有循环引用的方法，故放弃
    可达性分析算法：
        可作为 GC Root 的对象包括以下4种：
        1虚拟机栈（栈帧中的本地变量表）中引用的对象
        2方法区中类静态属性引用的对象
        3方法区中常量引用的对象
        4本地方法栈中 JNI（即一般说的 Native 方法）引用的对象

    标记 --- 清除算法
    复制算法
    标记整理算法
    分代收集算法：在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。
                 而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或者标记 --- 整理算法来进行回收

六、ThreadLocal key为什么设计成弱引用？
    对于一个 ThreadLocal 对象，通常会有两个引用指向它：
        一个是线程中声明的 threadLocal 变量，这是个强引用；
        一个是线程底层 ThreadLocalMap 中键值对的 key，这是弱引用。
    不再需要使用某 ThreadLocal 对象时，会采用将变量设置为 null（threadLocal = null）的方式释放掉线程中 threadLocal 变量与对象之间的引用关系，方便 GC 对 ThreadLocal 对象的回收。
    但此时线程的 ThreadLocalMap 中还有 key 引用着这个 ThreadLocal 对象：如果这个引用是强引用，那么这个 ThreadLocal 对象就可能永远不会被回收了，造成内存泄露；
    但现在这里设计成弱引用，那么当垃圾收集器发现这个 ThreadLocal 对象只有弱引用相关联时，就会回收它的内存。

七、String 类能不能被继承？为什么？
    主要是为了 “ 效率 ” 和 “ 安全性 ” 的缘故。 若 String 允许被继承, 由于它的高度被使用率, 可能会降低程序的性能，所以 String 被定义成 final。

    只有当字符串是不可变的，字符串池才有可能实现。
    因为字符串是不可变的，所以是多线程安全的。
    类加载器要用到字符串，不可变性提供了安全性。
    因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键。

八、JMM 中内存模型是怎样的？什么是指令序列重排序？
    堆、方法区。本地方法栈、虚拟机栈、程序计数器。

    指令序列的重排序：
    1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
    2）指令级并行的重排序。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
    3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

九、Java 线程和操作系统的线程是怎么对应的？Java线程是怎样进行调度的?（？？）
    Linux 2.6上的HotSpot使用了NPTL机制，JVM线程跟内核轻量级进程有一一相应的关系
    Java线程在Windows及Linux平台上的实现方式是内核线程的实现方式。
    这样的方式实现的线程，是直接由操作系统内核支持的——由内核完毕线程切换，内核通过操纵调度器（Thread Scheduler）实现线程调度，并将线程任务反映到各个处理器上。
    内核线程是内核的一个分身。程序一般不直接使用该内核线程，而是使用其高级接口，即轻量级进程（LWP）。也即线程。

十、简述 BIO, NIO, AIO 的区别？
    bio :同步阻塞，服务器实现模式是一个连接一个线程，当客户端发来连接时服务器就需要启动一个线程进行处理，
        如果这个连接不做任何事情就会造成不必要的线程开销，当然线程池机制可以改善。

    nio:同步非阻塞，服务器实现模式为多个请求一个线程，即客户端发来的请求都会注册到多路复用器上，
        多路复用器轮训的连接有io请求时才开启一个线程进行处理。

    aio:异步非阻塞，服务器实现模式为多个有效请求一个线程。
        即客户端发来的请求由os处理完成才会通知服务器应用启动线程进行处理。
