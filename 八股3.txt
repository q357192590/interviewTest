一、会话跟踪技术
    主要分为以下几种
    1.Cookie技术
        Cookie技术是一种在客户端保持会话跟踪的解决方案，会话数据保存在客户端浏览器。
        Cookie在用户第一次访问服务器时，由服务器通过响应头的方式发送给客户端浏览器；当用户再次向服务器发送请求时会附带上这些文本信息。
    2.Session技术
        Session是指使用HttpSession对象实现会话跟踪的技术，是一种在服务器端保持会话跟踪的解决方案。
    3.URL重写技术
        URL重写即使浏览器不支持 cookie 或在用户禁用 cookie 的情况下，这种方案也能够工作。
    4.隐藏表单域技术
        HTML 表单中可以含有如下的条目：<input type="hidden" name="session" value="a1234">
        这个条目的意思是：在提交表单时，要将指定的名称和值自动包括在 GET 或 POST 数据中。这个隐藏域可以用来存储有关会话的信息，
        但它的主要缺点是：仅当每个页面都是由表单提交而动态生成时，才能使用这种方法。

二、JVM生产环境具体优化？
    1.JDK1.8+优先使用G1收集器，可以摆脱各种烦恼。
        java -jar -XX：+UseG1GC -Xms2G -Xms2G -Xss256k
        -XX：MaxGCPauseMillis=300
        -Xloggc：/logs/gc.log -XX：+PrintGCTimeStamps -XX：PrintGCDetails test.jar

        I、-Xms与-Xmx设置相同，减少动态内存调整所带来的内存交换
            评估-Xmx方法：第一次起始设计大一点，跟踪监控日志，调整为堆峰值*2~3即可
        II、最多300ms的STW的时间，在200~500区间即可，增大时可减少GC次数，提高吞吐
        III、-Xss设置为128k/256k。JDK1.5以后虚拟机栈默认每个线程分配1M空间，有些多余，若处理线程过多，内存压力很大。
            同时业务不涉及复杂运算，128K够用。涉及复杂运算256K也够用。所以超过256K就要考虑优化，不建议超过256k。
        IV、G1一般不设置新生代的大小-Xmn，因为G1新生代是动态调整的。

三、线上OOM具体排查？
    一、
        1.jps
        2.jstat -gcutil pid 1000 10










        3.使用jstack太难看懂
    二、可以安装使用arthas
        4.直接通过java -jar命令启动arthas，在向导中选择你想监控的进程号。
        5.dashboard命令可以通过仪表盘的方式动态的在线展示jvm的运行情况。
        6.如果想看详细信息，例如当前内存中哪个对象没有被正常释放，它占用空间是多少，堆栈信息等
            可以使用与jmap相似的一个命令heapdump去把堆中所有信息dump到某个文件中
            heapdump /tmp/dump.hprof
        7.用xftp把dump文件下载到本地的某个目录，通过visualVM的离线分析功能去对dump文件可视化分析


四、如何全表扫描一个大表？
    全表扫描在数据库上优化的余地很小，完全是看你系统的IO的能力。

    1使用多台机器并行扫描一张表
        但是这样需要对整个表加锁，并不适合在并发量很大的场景使用
    2.表分区
        通过一致性hash进行分区，然后通过多线程进行扫描。
    3.钞能力，高端存储。


五、业务层如何实现高可用？
    1.扩展
        扩展是最常见的提升系统可靠性的方法，系统的扩展可以避免单点故障。
        1. 垂直扩展：是在同一逻辑单元里添加资源从而满足系统处理能力上升的需求。比如，当机器内存不够时，我们可以帮机器增加内存，或者数据存不下时，我们为机器挂载新的磁盘。
        2. 水平扩展：通过增加一个或多个逻辑单元，并使得它们像整体一样的工作。

        在实际应用中，水平扩展最常见：
        通常我们在部署应用服务器的时候，都会部署多台，然后使用 nginx 来做负载均衡，nginx 使用心跳机制来检测服务器的正常与否，无响应的服务就从集群中剔除。
            这样的集群中每台服务器的角色是相同的，同时提供一样的服务。
    2.限流
        一个系统的处理能力是有上限的，当服务请求量超过处理能力，通常会引起排队，造成响应时间迅速提升。
            如果对服务占用的资源量没有约束，还可能因为系统资源占用过多而宕机。
        常见的限流算法有：漏桶、令牌桶、滑动窗口计数。
        1漏桶算法可以使用 Redis 队列来实现，生产者发送消息前先检查队列长度是否超过阈值，超过阈值则丢弃消息，否则发送消息到 Redis 队列中；
            消费者以固定速率从 Redis 队列中取消息。Redis 队列在这里起到了一个缓冲池的作用，起到削峰填谷、流量整形的作用。
        2Guava 中的限流工具 RateLimiter，其原理就是令牌桶算法
    3.降级
        通过开关控制，降级部分非主流程的业务功能，减轻系统依赖和性能损耗，从而提升集群的整体吞吐率。
        降级的典型应用是：电商活动期间关闭非核心服务，保证核心买买买业务的正常运行。
        降级和熔断可用hytrix。
    4.熔断
        在分布式系统中，如果调用的远程服务或者资源由于某种原因无法使用时，没有这种过载保护，就会导致请求阻塞在服务器上等待从而耗尽服务器资源。
            很多时候刚开始可能只是系统出现了局部的、小规模的故障，然而由于种种原因，故障影响的范围越来越大，最终导致了全局性的后果。即避免级联故障。
        熔断器的基本原理，包含三个状态：
            1服务正常运行时的 Closed 状态，当服务调用失败量或失败率达到阈值时，熔断器进入 Open 状态
            2在 Open 状态，服务调用不会真正去请求外部资源，会快速失败。
            3当进入 Open 状态一段时间后，进入 Half-Open状态，需要去尝试调用几次服务，检查故障的服务是否恢复。如果成功则熔断器关闭，如果失败，则再次进入 Open 状态。
    5.灰度发布



六、项目的工单表字段？
    wo_no, /* 工单号 */
    order_no, /* 订单号 */
    bill_no,/*服务单号*/
    download_time, /* 下传时间 */
    reply_time, /*回复时间*/
    reply_business_type_noe, /* 回复业务类型一级
    reply_business_type_two, /* 回复业务类型二级
    sku, /* 商品编号 */
    category_no, /* 品类编号 */
    category_name, /* 品类名称 */
    brand_no, /* 品牌编号 */
    brand_name, /* 品牌名称 */
    wo_state, /* 工单状态 */

七、项目的修改表结构
    建表sql：
    ALTER TABLE wo_work_order ADD(
        `customer_name` VARCHAR(15) DEFAULT '' NOT NULL COMMENT '客户姓名',
        `customer_phone` VARCHAR(15) DEFAULT '' NOT NULL COMMENT '手机'
    )

八、京东改进之后的JSF？
    JSF相比于Dubbo而言多了一个注册中心寻址服务，为什么会这样呢？主要是因为2015年双十一时候注册中心挂了以后，后端容器服务重启以后之前缓存的服务地址列表丢失，服务无法调用。
        而且以Zookeeper为注册中心的Dubbo，会受制于Zookeeper的缺点：在Zookeeper主节点挂了以后，新的主节点被选出来之前，Zookeeper集群不可用。
        而且Zookeeper没有动态水平扩展的能力。由此可见注册中心是瓶颈。所以京东在这一块做了改进，我觉得就是抛弃Zookeeper集群，自己取长补短的去实现一个服务治理。

    1.引入了index概念，我的理解就是将注册中心根据不同的业务分片，不同的业务模块访问不同的注册中心以实现负载均衡，而不像以前的注册中心逻辑上就是一个整体。
        因此也需要注册中心寻址服务，在一开始定位到自己的注册中心。
    2. 注册中心可以实现水平扩容，监控到压力大即可进行动态水平扩展

九、Kafka为什么高性能？kafka和RocketMQ适用场景？
    1.磁盘顺序读写
    2.页缓存
    3.零拷贝
    4.批量操作

    RocketMQ适合业务到达速度很快，但是并行比较少
    kafka更在乎高吞吐量，适合并行处理任务

十、cassandra列式数据库为什么性能高？
    产品：HBase，cassandra（卡森拙儿）
    应用场景：批量处理，超大规模即时查询
    原因：
        行式存储，在查询时会跳磁盘查询和输出结果，磁头转动距离过大，会产生大量的io浪费，大量时间用在硬盘的寻址上。





        列式存储，数据在磁盘上以列的方式做紧密存储，磁盘顺序读效率很高，不会读取无用数据。
            同时因为每一列数据库类型都是一致的，数据压缩比大，节省磁盘空间，对缓存可以进行更高效的利用。






    问题：
        如何高效新增：多个列族，并发写磁盘，不对原数据修改，追加即可。
        如何高效更新：不允许修改原始数据，把原数据复制一份增加到磁盘的末尾，添加一个新版本号，查询时只要去查询最新版本号的数据。老版本定时批量清除。
        如何高效删除：添加删除标记keyType=Delete。相当于逻辑删除。cassandra在闲时会去统一删除，即空间换时间。


十一、介绍下中断？
    中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。
    Linux为了解决中断处理程序执行时间过长和中断丢失的问题，把中断过程分成两个阶段，分别是上半部和下半部。
        上半部（硬中断）用来快速处理中断，一般会关闭中断请求，主要负责处理和硬件紧密相关或者时间敏感的事情。
            耗时间短，快速执行，会打断cpu正在执行的任务。
        下半部（软中断）处理上半部未完成的工作，一般以内核线程的方式运行。
            耗时长，延迟执行，不会打断，以内核线程的方式执行。
    例如网卡收到网络包，会通过硬件中断通知内核有新的数据到了。硬中断把网卡的数据读到内存，更新硬件寄存器的状态位。软中断从内存中找到
        网络数据，再按照网络协议栈，对网络数据逐层解析和处理，最后把数据送给应用程序。


十二、进程的上下文切换，线程的上下文切换有什么区别？
    进程：不仅包含虚拟内存、堆、栈、全局变量等用户空间的资源，还包括内核堆栈，页表，寄存器等内核空间的资源。
    线程：若两个线程属于同一个进程，虚拟内存资源是共享的，保持不动即可，只需要切换线程的私有数据，寄存器等不共享的数据。

十三、redis的rdb持久化
    #save时间，以下分别表示更改了1个key时间隔900s进行持久化存储；更改了10个key时间隔300s进行存储；更改10000个key时间隔60s进行存储。

    save 900 1

    save 300 10

    save 60 10000

    这里我们可以继续添加，也可以修改参数   比如 save 10 10000  10000个数据时间间隔10s就持久化

十四、为什么要读写分离呢？
    1、主从服务器可以负责各自的读和写，极大程度缓解了锁的争用。
    2、从服务器可以使用MyISAM，提升查询性能及节约系统开销。
    3、增加冗余，提高可用性。


十五、MongoDB的使用场景，优势？
    1、如果同一个集合中包含不同字段的对象，用Mysql会非常麻烦，而MongoDB可以直接存储JSON。
    2、MongoDB对于某个数据要添加字段很友好，因为不涉及到其他数据，可以先上修改数据。
    3、MongoDB支持使用JSON Schema来规范数据模式，在保证灵活的基础上对数据做最基础的约束。

    （数据是全量保存！！！！！！！！！！）
    优势：1、数据库在一个连续紧密存储区读写（速度快）
        2.反范式、无关联的组织极大优化查询速度（速度快）
        3、api简单，开发自然。
        4、MongoDB自带自恢复，多中心同步，分片方案。

十六、如何使用Mysql Ngram全文检索技术实现模糊查询？
    从MYSQL5.7.6开始引入，允许对短文本进行全文检索查询，以替代like关键字，但是对于复杂业务场景的全文检索查询，还是要用ES。

    1、在建表时对相应字段建立 FULLTEXT索引，意思是对指定字段使用NGRAM的全文检索的解析。
    2、设置分词的大小，例如nagram_token_size = 2
    3、sql修改：select *，MATCH（字段1，字段2) AGAINST（'模糊字段'） as score from............
        按分词的相似度算分，分数从高到底倒序排列。

    注意：1、MATCH函数使用的字段名必须和创建全文索引时指定的字段名一致
        2、MATCH使用的字段名只能是同一个表的字段，因为全文索引不能够跨多个表进行检索
        3、如果要导入大数据集，最好是先导入，再创建全文索引，比现在表上创建全文索引再导入数据的方式快很多。