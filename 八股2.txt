1、多级缓存架构？








    客户端缓存（静态资源）：
            在浏览器层面主要缓存css，js，字体等静态资       源文件
            例如：百度的图标，服务器在响应头中设置expires，浏览器在该段时间将图片以文件缓存在本地，客户端再次访问会看到
                from disk cache的提示，浏览器不再请求服务器，而是直接在本地取图片。
            可以很大程度上缓解浏览器重复请求静态资源的带宽损耗，客户端只需要缓存文件就可以。
    应用层缓存（静态资源）：
            CDN内容分发网络，是互联网静态资源分发的主要技术手段，是广域的互联网应用的基础设施，有效解决了带宽集中占用、资源分发的问题。
            CDN的核心技术是智能DNS。






            例如：大量上海用户访问北京资源。
            但是投入较高，可以租用阿里云、腾讯云、华为云提供的CDN服务，进行租用。

            对于企业级应用，工作人员往往分布在指定的工作区域，或相对固定的场所，再加上并发度并不是很高，
                也就没必要去部署CDN这样重量级的解决方案，可以在架构部署Nginx，利用其自带的静态资源缓存的能力和压缩的功能，
                就可以胜任绝大多数企业级应用场景。Nigix实际是在本地通过一个个目录的方式组织。

    服务层缓存（缓存后端接口查出的数据）：
            进程内缓存：应用中开辟内存空间，进程在运行中载入这块内存，通过本地内存的低延迟，高吞吐特性来提高程序的访问速度（ehCache）
            进程外缓存：分布式缓存（redis），集中缓存。

            先进到远、由快到慢的访问缓存。网络是不确定的，同时访问也是有上限的，所以不能上来就找Redis。
            要在应用端要设计多级应用缓存，通过进程内缓存和进程外缓存结合分摊压力。先看进程内缓存，再看进程外缓存，都查不到再去db，然后写回缓存。

            因为引入多级缓存，要考虑分布式缓存数据一致性问题，此时可以通过MQ主动推送给别的服务实例变更的数据。各实例收到后先删除本地缓存，再重新创建，以保存各实例的数据一致。

2、何时采用多级缓存架构？






3、MySqL集群模式与应用场景
    单库模式：






    读写分离模式：






    分库分表（分片）模式：








        分片算法：




    互联网主流MYsql集群架构：







4、为什么要垂直分表？何时进行垂直分表？
    innodb在1.0以后引入了压缩页，在跨页上解压缩和压缩的执行效率不高，所以表在设计的时候，要尽可能保证每一页内尽可能的多存储一些行数据。
    通过将重要字段剥离，让一页能容纳更多的行，进而缩小数据扫描的页范围，减少跨页检索，检索效率变高。

    数据总量很大且字段超过20，且包含了超长的varchar，CLOB，BLOB。

    主表中主要存放：查询（skuid，商户id）、排序时需要的字段（品牌编号）、高频访问的小字段（商品名称、价格）。
    从表中需要存放：低频访问字段、大字段（图文详情、图片BLOB）

5、为什么在大表严禁使用自增主键？
    在分布式下有严重的问题。
    1、每个分片能承载多少数据，只能靠猜，可能会产生比较大的浪费，不能在运行期间动态扩展的
    2、因为自增主键是在数据库层面生成自增的序列，那么数据库集群必须按主键范围分片（不能hash分片）
    3、范围分片会导致“尾部热点”效应。所有的操作都在一个热点分片上集中处理，该分片的数据库压力会非常大，而其他分片的数据库却没什么压力。

6、为什么不能使用uuid作为主键？
    1、128位，比起整形、长整形浪费空间。
    2、因为无序，作为主键会产生大量的索引重排（可见part1 -51）

7、简介雪花算法SnowFlake？
    有序，且每个机器上序列唯一。






    但是雪花算法要注意时间回拨的问题。但是平常基本不会去时间回拨。
8、布隆过滤器原理？
    二进制数组+n个hash函数。
    在数组中通过hash函数将有效数据所映射的n个位置为1。

    检验数据时，如果全部为1，则代表可能含有该数据。如果出现0，则代表肯定不含此数据。使用的时候只需maven引入redission，其中集成了bloomFilter。

    问题：商品删除了该怎么办？
        布隆过滤器因为某一位二进制可能被多个编号hash映射，因此布隆过滤器无法直接处理删除数据的情况。
        方案1、定时异步重建布隆过滤器（例如每4小时）
        方案2、计数bloomFilter

9、阿里开发规范解读：为啥禁用外键约束？
    表的外键是另一表的主键
    1、额外的数据一致性校验查询，会去另一张表查是否唯一等。
    2、并发问题：外键约束会在主表启用行级锁（共享锁），主表写入或者更新时（开启独占锁），若独占锁一直不释放，详情表会一直阻塞状态。从外界来看，
        所有详情表的写操作，都会因为主表的锁定进入阻塞，可能会导致大量的线程积压，甚至造成系统延迟，崩溃。
    3、级联删除：多层级联删除会让数据变的不可控。禁用是为了数据健壮和可追溯。
    4、数据耦合：数据库层面数据关系产生耦合，数据迁移维护困难，例如：数据多了，将数据源迁移，迁移至大数据库HBASE上，主外键无意义，需要去掉，那么以前程序里未校验的代码可能就出现问题。

10、为什么开发要禁用数据库IP直连？
    会造成两个模块之间强耦合。更换IP时费劲。
    解决：
        1、引入内部DNS：





        2、注册中心：





11、JDBC连接数据库的步骤？
    JDBC连接数据库可以概括为6步，分别是加载JDBC驱动、建立数据库连接、创建一个语句对象、执行一个查询、处理结果集和关闭数据库连接。
    1、加载JDBC驱动
        使用java反射机制中的方法forName()进行加载，如：Class.forName(“com.mysql.jdbc.Driver”);
    2、建立数据库连接
        驱动管理类DriverManager使用特定的驱动程序，通过getConnection(String url)方法建与某个特定数据库的连接。每个JDBC驱动都对应一个URL地址用于自我标识
    3、创建一个语句对象
        创建一个语句对象则需要调用接口java.sql.Connection中的createStatement()方法创建Statement类的语句对象，
        通过创建一个语句对象则可以发送SQL语句到数据库准备执行相应的操作。
    4、执行SQL语句
        将SQL语句发送到数据库之后，根据发送的SQL语句确定执行executeQuery()方法或executeUpdate()方法。
    5、处理结果集
        如果需要从返回的结果集中获取数据，那么可以通过结果集对象调用ResultSet接口的getXXX()方法进行获取。
    6. 关闭数据库连接
        结果集处理完成之后，为了释放资源需要在finally语句块中首先关闭语句对象，再关闭数据库连接，如：
        stmt.close();      //关闭语句对象。
        conn.close();     //关闭数据库连接。

12、浮点数运算
    用BigDecimal
    public class Test {
    public static void main(String[] args) {
        System.out.println((new BigDecimal("2.0")).subtract(new BigDecimal("1.9")).doubleValue());
        }
    }

    api：
        1、BigDecimal(T)
        2、add(BigDecimal) BigDecimal对象中的值相加，返回BigDecimal对象
        3、subtract(BigDecimal) BigDecimal对象中的值相减，返回BigDecimal对象
        4、multiply(BigDecimal) BigDecimal对象中的值相乘，返回BigDecimal对象
        5、divide(BigDecimal) BigDecimal对象中的值相除，返回BigDecimal对象
        6、doubleValue() 将BigDecimal对象中的值转换成双精度数
        7、intValue() 将BigDecimal对象中的值转换成整数
        8、int a = bigdemical.compareTo(bigdemical2) java中对BigDecimal比较大小一般用的是bigdemical的compareTo方法


13、如何实现MySQL异构数据同步？
    阿里Canal + MQ。主要作用：数据监听 + 解耦。
    canal原理：










    整体方案：










14、工厂模式?
    目的：实现调用者和创建者的解耦，调用者无需了解创建细节（比如相关参数），只需使用

    核心本质:
        实例化对象不适用new, 用工厂方法代替
        将选择实现类，创建对象统一管理和控制，从而将调用者跟我们的实现类解耦

    三种模式:
        简单工厂模式:
            用来生产同一等级结构中的任何产品(对于增加新的产品，需要扩展已有代码)
        工厂方法模式:
            用来生产同一等级结构中的固定产品(支持增加任意产品)
        抽象工厂模式:
            围绕一个超级工厂创建其他工厂，该超级工厂又被称为其他工厂的工厂

15、建造者模式？
    使用多个简单的对象一步一步构建成一个复杂的对象，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
    指挥者通过指挥不同的工人、按不同的顺序建造，可以得到不同的产品。相比工厂模式的生产零件，建造者模式更像汽车的组装工厂。
    允许用户只通过指定复杂对象的类型和内容就可以构建它们，不需要知道内部的具体构建细节
    何时使用：一些基本部件不会变，而其组合经常变化的时候。

    核心组成：
        1Builder：抽象建造者，定义多个通用方法和构建方法
        2ConcreteBuilder：具体建造者，可以有多个
        3Director：指挥者，控制整个组合过程，将需求交给建造者，由建造者去创建对象
        4Product：产品角色

16、桥接模式？
    桥接模式提高了系统的可扩展性，在不同的维度中任意扩展一个维度，都不需要修改原系统，负责开闭原则。
    就像一座桥，把两个有独立变化的维度组合起来。
    例子：JDBC的驱动程序、JAVA虚拟机实现了平台的无关性。









17、单一索引和联合索引优先使用哪个？
    当创建**(a,b,c)联合索引时，相当于创建了(a)单列索引**，(a,b)联合索引以及**(a,b,c)联合索引**
    复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。
        如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。
    所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；
        仅对后面的任意列执行搜索时，复合索引则没有用处。

    多个单列索引在多条件查询时优化器会选择最优索引策略，可能只用一个索引，也可能将多个索引全用上！
        但多个单列索引底层会建立多个B+索引树，比较占用空间，也会浪费一定插入修改效率，故如果只有多条件联合查询时最好建联合索引！

18、什么是跨域问题？Springboot中关于跨域问题的解决方法？
    URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口全部相同，则表示他们同源。
        否则，只要协议、域名、端口有任何一个不同，就是跨域。

    在Spring Boot 2.X应用程序中可以使用注解@CrossOrigin，也可以通过使用WebMvcConfigurer对象来定义全局CORS配置。
        1、可以通过实现WebMvcConfigurer接口，然后重写addCorsMappings方法解决跨域问题。
        2、在Controller或者其中业务方法上加上注解@CrossOrigin(origins = "http://localhost:8080");

19、各种MQ优缺点？














20、Redis的使用场景？
    1、热点数据的缓存
    由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，
        我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。

    2、限时业务的运用
    redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

    3、计数器相关问题
      redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、
      具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

    4、排行榜相关问题
    关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的ZSet进行热点数据的排序。

    5、分布式锁
    这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0，
        因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先通过setnx设置一个lock，如果成功设置则执行，
        如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，防止死锁的出现。

    6、分布式的集中存储
    分布式session、分布式id的集中存储之地。

21、服务器响应比较慢，接口慢？你怎么排查，或者列出你认为可能出现的问题点？
    第一步，检查网络
        ping命令检查网络域名解析是否正常，ping服务器的延迟是否过大，如果过大可以检查Ip是否冲突，或者交换机网线是否正常插好，
        通过nmon还可以查看网络流量，一般用的千兆交换机理论速率是1000/8=125MB每秒，但是这理论峰值一般都无法达到，
        所以如果网络流量达到了80~100MB每秒则可以判定瓶颈在交换机上，也可以用telnet来查看端口访问是否正常。
        通过这些方式，首先排除网络可能出现的问题

    第二步，检查服务器内存
        如果请求响应速度慢，一般跟内存关联比较大，通过free -m, vmstat 1，nmon工具等方式判断内存资源是否紧缺

    第三步，查看CPU负载
        可以通过sar、vmstat、top、nmon等工具或命令判断cpu是否过载，如果没有问题那就进行第四步

    第四步，检查磁盘IO
        可以通过iostat 1、vmstat 、nmon等命令检查磁盘的读写，如果没有问题，linux系统自身的性能问题基本排除

    第五步，抓取进程堆栈信息
        通过jstack -l pid | tee -a out.log 将pid的堆栈信息抓取出来，放到out.log的文件中分析，看是在java进程的哪一步耗时较大，然后针对那部分代码进行优化

    第六步、如果单进程没问题、思考点：
        1死锁、资源抢占
        2网络攻击
        3增加CDN、多级缓存
        4数据量过大，使用ES搜索

22、JVM调优介绍
    1查看正在运行中jvm参数是否开启或其值：
        jps :查看后台进程，可以得到进程编号
        jinfo -flag :配置项 PID 查看运行的java程序的各种信息
        jinfo -flags PID :查看所有配置项
        例：命令行（jinfo -flag PrintGCDetails PID） 输出-> -XX:+PrintGCDetails

    2查看所有配置项初始默认值、配置项修改更新值、常用配置：
        java -XX:+PrintFlagsInitial
        java -XX:+PrintFlagsFinal
        java -XX:+PrintCommandLineFlags

    3
    标配参数：
        -version 、 -help
    X参数：
        -Xint解释执行 、-Xcomp编译执行 、 -Xmixed混合模式（先编译后执行）
    XX参数：
        布尔类型：
            -XX:+PrintGCDetails 打印垃圾回收细节
            -XX:+UseSerialGC
        KV类型：
            -Xms <==> -XX:InitialHeapSize=8372
            -Xmx <==> -XX:MaxHeapSize=1024
            -Xss <==> -XX:ThreadStackSize=1024
            -Xmn <==> 设置年轻代大小，一般不调
            -XX:MetaspaceSize=1024m，默认20M左右
            -XX:SurvivorRation 设置新生代中eden比例，一般不调
            -XX:NewRatio 设置老年代的比例
            -XX:MaxTenuringThreshold=15 最大新生区的年龄，一般不调

    补充：1、默认最大堆内存是物理内存的1/4
        2、初始堆内存是物理内存的1/64
        3、新生代一般是堆大小1/3，老年代一般是堆大小2/3
        4、新生代中eden:S0:S1默认8:1:1
        5、MaxTenuringThreshold 范围0~15

23、反射的应用场景及优缺点？
    反射常见的应用场景这里介绍3个：
        Spring 实例化对象：当程序启动时，Spring 会读取配置文件applicationContext.xml并解析出里面所有的<bean>标签实例化到IOC容器中。
        反射 + 工厂模式：通过反射消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，反射可以使得程序更加健壮。
        JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的驱动类时用到反射加载驱动类

    反射的优点：
        增加程序的灵活性：面对需求变更时，可以灵活地实例化不同对象。例如通过传入参数param决定使用哪一种类。
    缺点：
        破坏类的封装性：可以强制访问 private 修饰的信息
        性能损耗：反射相比直接实例化对象、调用方法、访问变量，中间需要非常多的检查步骤和解析步骤，JVM无法对它们优化。

24、创建进程和线程，有哪些系统调用可以用？
    在Linux中主要提供了fork、vfork、clone三个进程创建方法。

    fork创建一个进程时，子进程只是完全复制父进程的资源，复制出来的子进程有自己的task_struct结构和pid,但却复制父进程其它所有的资源。
    vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。
    clone()是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，
        具体要复制哪些资源给子进程，由参数列表中的clone_flags来决定。

    系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，clone()是选择复制。

25、内核或者CPU怎么把你的逻辑地址转化为物理地址？
    Linux内核里把线性地址转换成物理地址是通过页表映射来实现的。页表映射具体还可以分为二级页表、三级页表等。
    页表记录了逻辑页与物理页帧的对应关系，实现从页号到物理块号的地址映射。然后cpu通过物理基地址和页内偏移即可得到物理地址。

26、MMU是什么？TLB是什么？
    MMU
        1）将线性地址映射为物理地址
        2）提供硬件机制的内存访问授权（把不同的进程映射到独立的物理地址）
    TLB
        转译后备缓冲器，也被翻译为页表缓存、转址旁路缓存，为CPU的一种缓存，由存储器管理单元用于改进虚拟地址到物理地址的转译速度

27、操作系统里的I/O模型？
    阻塞IO、非阻塞IO、 IO多路复用、信号驱动式IO、异步IO。

28、SELECT、POLL、EPOLL是NIO还是BIO的模型？是同步调用还是异步调用？
    select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），
    能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，
    也就是说这个读写过程是阻塞的（可能通过while循环来检测内核将数据准备的怎么样了， 而不是属于内核的一种通知用户态机制），
    仍然需要read、write去读写数据。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。
    即异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

29、请求重传ARQ分类？
    传统自动重传请求分成为三种，即停等式(stop-and-wait）ARQ，回退n帧（go-back-n）ARQ，以及选择性重传（selective repeat）ARQ。
    后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为连续ARQ协议。
    三者的区别在于对于出错的数据报文的处理机制不同。三种ARQ协议中，复杂性递增，效率也递增。

    停等式ARQ：
        在停等式ARQ中，数据报文发送完成之后，发送方等待接收方的状态报告，如果状态报告报文发送成功，发送后续的数据报文，否则重传该报文。
        发送窗口和接收窗口大小均为1，发送方每发送一帧之后就必须停下来等待接收方的确认返回，仅当接收方确认正确接收后再继续发送下一帧。
        该方法所需要的缓冲存储空间最小，缺点是信道效率很低。

    回退n帧的ARQ
        发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么从那个发生错误的帧开始及其之后所有的帧全部再重新发送。

    选择性重传ARQ
        发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么发信侧将只重新发送那个发生错误的帧。

30、请求重传报文的是发送端还是接收端?
    当数据包没有成功被接收端接收时，接收端不发送ACK包，发送端将继续等待一段时间并重新发送数据包.直到接收到接收端发来的ACK。

31、TCP连接的SOCKET编程，会用到哪些系统调用和函数？
    socket（）：创建套接字。
    bind（）：指定本地地址。一旦创建了一个套接字，服务器就必须使用bind（）系统调用为套接字建立一个本地地址。
    connect（）：将套接字连接到目的地址。初始创建的套接字并未与任何外地目的地址关联。
        客户机可以调用connect（）为套接字绑定一个永久的目的地址，将它置于已连接状态。
    listen（）：设置等待连接状态。listen函数是用来设置监听连接的句柄和队列，当listen函数执行完成以后，服务端就已经可以接受客户端来的新连接了，
        新连接完成以后listen会把客户端的ip，port和连接句柄放在监听队列里面，等待accept函数来取，如果监听队列满了，listen会拒绝新来的连接。
    accept（）：接受连接请求。然后，服务器调用accept进入等待状态，直到到达一个连接请求。
    send（）/recv（）和sendto（）/recvfrom（）：发送和接收数据 。
    closesocket（）：关闭套接字。

    系统调用：
        sock_create函数：创建socket
        sock_map_fd函数：将file文件结构和fd文件描述符关联，同时将上一步返回的socket也一起绑定

32、静态代理？动态代理？
    一：静态代理是由程序员创建生成代理类，再对其编译，在程序运行之前，代理类.class文件就已经被创建了。
    二：动态代理是在程序运行时通过反射机制动态创建代理对象。

33、上亿的表插入怎么处理？
    插入速度不快：
    1、分表可以通过时间或者其他口径进行切片，原来有个项目中，有个大表是保存员工发送的消息记录，每年一亿条左右，5万员工，按年切片成表，
        每年的消息记录创建一个历史表，索引设计得当，查询速度满足要求，都保存在一台服务器上的一个mysql库运行多年。

    插入速度很快：
    1、如果你的表建了索引，除了主索引其他一定要先删掉，否则插入速度会越来越慢。数据插入完成后再建索引，重建索引也会花不少时间
    2、首先是分表+一致性hash策略，每个表的数据最好控制在百万级，
        是否要拆分服务器，这个看你的情况，如果负载很高，就得分库，然后把不同的库放到不同的服务器上了。
    3、走大数据方案，HBASE、HIVE

34、慢SQL怎么处理？
    （1）索引没起作用的情况
        MYSQL8.0
        EXPLAIN
            type 出现 ALL 或者 index 的；
            possible_keys 出现过多（待选）索引；
            key 为 NULL 的（没走索引）；
            rows 过多，或者几乎是全表的记录数的；
        各种使用不当的情况。
    （2）优化数据库结构
        1. 垂直分表，将字段很多的表分解成多个表  2. 增加字典表，防止跨节点join
    （3）分解关联查询
        将一个大的查询分解为多个小查询，在service层组合。
    （4）优化LIMIT分页
        先查询出90000条数据对应的主键id的值，然后直接通过该id的值直接查询该id后面的数据。
        select id,title from collect limit 90000,10;
        优化为：select id,title from collect where id>=(select id from collect order by id limit 90000,1) limit 10
    （5）CDN服务
        服务器比较远


35、linux查看端口占用情况
    1、lsof -i:端口号 用于查看某一端口的占用情况
        比如查看8000端口使用情况，lsof -i:8000

36、MQ核心组件
    ActiveMQ 使用时包含的基本组件各与 JMS 是相同的：

        Broker，消息代理，表示消息队列服务器实体，接受客户端连接，提供消息通信的核心服务。
        Producer，消息生产者，业务的发起方，负责生产消息并传输给 Broker 。
        Consumer，消息消费者，业务的处理方，负责从 Broker 获取消息并进行业务逻辑处理。
        exchanger，交换机。
        Queue，队列，点对点模式下特定生产者向特定队列发送消息，消费者订阅特定队列接收消息并进行业务逻辑处理。
        Message，消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务 数据，实现消息的传输。
        Topic，主题，发布订阅模式下的消息统一汇集地，不同生产者向 Topic 发送消息，由 Broker 分发到不同的订阅者，实现消息的广播。

37、Redis是线程安全的吗？如何保证线程安全？
    1、Redis中本身就是单线程的能够保证线程安全问题。redis是单线程运行，所以多个redis命令是一个一个执行，所以是线程安全的.
        Redis实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题。

    2、不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁。
        分开的两个redis命令，对于【应用】不是线程安全的，因为这两个redis命令之间会有其他命令，就像java线程不安全的i++操作，
        这个两个redis命令没有事务管理 。

    3. 可以用RPOPLPUSH或者INCR , 或者lua脚本，实现多个redis操作合为一个命令，这样就对【应用】线程安全了

38、MySQL高可用架构方案？
    MHA:















39、Redis的Sentinel高可用架构？























40、阿里巴巴Seata分布式事务解决方案？

















