1、多级缓存架构？








    客户端缓存（静态资源）：
            在浏览器层面主要缓存css，js，字体等静态资       源文件
            例如：百度的图标，服务器在响应头中设置expires，浏览器在该段时间将图片以文件缓存在本地，客户端再次访问会看到
                from disk cache的提示，浏览器不再请求服务器，而是直接在本地取图片。
            可以很大程度上缓解浏览器重复请求静态资源的带宽损耗，客户端只需要缓存文件就可以。
    应用层缓存（静态资源）：
            CDN内容分发网络，是互联网静态资源分发的主要技术手段，是广域的互联网应用的基础设施，有效解决了带宽集中占用、资源分发的问题。
            CDN的核心技术是智能DNS。






            例如：大量上海用户访问北京资源。
            但是投入较高，可以租用阿里云、腾讯云、华为云提供的CDN服务，进行租用。

            对于企业级应用，工作人员往往分布在指定的工作区域，或相对固定的场所，再加上并发度并不是很高，
                也就没必要去部署CDN这样重量级的解决方案，可以在架构部署Nginx，利用其自带的静态资源缓存的能力和压缩的功能，
                就可以胜任绝大多数企业级应用场景。Nigix实际是在本地通过一个个目录的方式组织。

    服务层缓存（缓存后端接口查出的数据）：
            进程内缓存：应用中开辟内存空间，进程在运行中载入这块内存，通过本地内存的低延迟，高吞吐特性来提高程序的访问速度（ehCache）
            进程外缓存：分布式缓存（redis），集中缓存。

            先进到远、由快到慢的访问缓存。网络是不确定的，同时访问也是有上限的，所以不能上来就找Redis。
            要在应用端要设计多级应用缓存，通过进程内缓存和进程外缓存结合分摊压力。先看进程内缓存，再看进程外缓存，都查不到再去db，然后写回缓存。

            因为引入多级缓存，要考虑分布式缓存数据一致性问题，此时可以通过MQ主动推送给别的服务实例变更的数据。各实例收到后先删除本地缓存，再重新创建，以保存各实例的数据一致。

2、何时采用多级缓存架构？






3、MySqL集群模式与应用场景
    单库模式：






    读写分离模式：






    分库分表（分片）模式：








        分片算法：




    互联网主流MYsql集群架构：







4、为什么要垂直分表？何时进行垂直分表？
    innodb在1.0以后引入了压缩页，在跨页上解压缩和压缩的执行效率不高，所以表在设计的时候，要尽可能保证每一页内尽可能的多存储一些行数据。
    通过将重要字段剥离，让一页能容纳更多的行，进而缩小数据扫描的页范围，减少跨页检索，检索效率变高。

    数据总量很大且字段超过20，且包含了超长的varchar，CLOB，BLOB。

    主表中主要存放：查询（skuid，商户id）、排序时需要的字段（品牌编号）、高频访问的小字段（商品名称、价格）。
    从表中需要存放：低频访问字段、大字段（图文详情、图片BLOB）

5、为什么在大表严禁使用自增主键？
    在分布式下有严重的问题。
    1、每个分片能承载多少数据，只能靠猜，可能会产生比较大的浪费，不能在运行期间动态扩展的
    2、因为自增主键是在数据库层面生成自增的序列，那么数据库集群必须按主键范围分片（不能hash分片）
    3、范围分片会导致“尾部热点”效应。所有的操作都在一个热点分片上集中处理，该分片的数据库压力会非常大，而其他分片的数据库却没什么压力。

6、为什么不能使用uuid作为主键？
    1、128位，比起整形、长整形浪费空间。
    2、因为无序，作为主键会产生大量的索引重排（可见part1 -51）

7、简介雪花算法SnowFlake？
    有序，且每个机器上序列唯一。






    但是雪花算法要注意时间回拨的问题。但是平常基本不会去时间回拨。
8、布隆过滤器原理？
    二进制数组+n个hash函数。
    在数组中通过hash函数将有效数据所映射的n个位置为1。

    检验数据时，如果全部为1，则代表可能含有该数据。如果出现0，则代表肯定不含此数据。使用的时候只需maven引入redission，其中集成了bloomFilter。

    问题：商品删除了该怎么办？
        布隆过滤器因为某一位二进制可能被多个编号hash映射，因此布隆过滤器无法直接处理删除数据的情况。
        方案1、定时异步重建布隆过滤器（例如每4小时）
        方案2、计数bloomFilter

9、阿里开发规范解读：为啥禁用外键约束？
    表的外键是另一表的主键
    1、额外的数据一致性校验查询，会去另一张表查是否唯一等。
    2、并发问题：外键约束会在主表启用行级锁（共享锁），主表写入或者更新时（开启独占锁），若独占锁一直不释放，详情表会一直阻塞状态。从外界来看，
        所有详情表的写操作，都会因为主表的锁定进入阻塞，可能会导致大量的线程积压，甚至造成系统延迟，崩溃。
    3、级联删除：多层级联删除会让数据变的不可控。禁用是为了数据健壮和可追溯。
    4、数据耦合：数据库层面数据关系产生耦合，数据迁移维护困难，例如：数据多了，将数据源迁移，迁移至大数据库HBASE上，主外键无意义，需要去掉，那么以前程序里未校验的代码可能就出现问题。

10、为什么开发要禁用数据库IP直连？
    会造成两个模块之间强耦合。更换IP时费劲。
    解决：
        1、引入内部DNS：





        2、注册中心：





11、JDBC连接数据库的步骤？
    JDBC连接数据库可以概括为6步，分别是加载JDBC驱动、建立数据库连接、创建一个语句对象、执行一个查询、处理结果集和关闭数据库连接。
    1、加载JDBC驱动
        使用java反射机制中的方法forName()进行加载，如：Class.forName(“com.mysql.jdbc.Driver”);
    2、建立数据库连接
        驱动管理类DriverManager使用特定的驱动程序，通过getConnection(String url)方法建与某个特定数据库的连接。每个JDBC驱动都对应一个URL地址用于自我标识
    3、创建一个语句对象
        创建一个语句对象则需要调用接口java.sql.Connection中的createStatement()方法创建Statement类的语句对象，
        通过创建一个语句对象则可以发送SQL语句到数据库准备执行相应的操作。
    4、执行SQL语句
        将SQL语句发送到数据库之后，根据发送的SQL语句确定执行executeQuery()方法或executeUpdate()方法。
    5、处理结果集
        如果需要从返回的结果集中获取数据，那么可以通过结果集对象调用ResultSet接口的getXXX()方法进行获取。
    6. 关闭数据库连接
        结果集处理完成之后，为了释放资源需要在finally语句块中首先关闭语句对象，再关闭数据库连接，如：
        stmt.close();      //关闭语句对象。
        conn.close();     //关闭数据库连接。

12、浮点数运算
    用BigDecimal
    public class Test {
    public static void main(String[] args) {
        System.out.println((new BigDecimal("2.0")).subtract(new BigDecimal("1.9")).doubleValue());
        }
    }

    api：
        1、BigDecimal(T)
        2、add(BigDecimal) BigDecimal对象中的值相加，返回BigDecimal对象
        3、subtract(BigDecimal) BigDecimal对象中的值相减，返回BigDecimal对象
        4、multiply(BigDecimal) BigDecimal对象中的值相乘，返回BigDecimal对象
        5、divide(BigDecimal) BigDecimal对象中的值相除，返回BigDecimal对象
        6、doubleValue() 将BigDecimal对象中的值转换成双精度数
        7、intValue() 将BigDecimal对象中的值转换成整数
        8、int a = bigdemical.compareTo(bigdemical2) java中对BigDecimal比较大小一般用的是bigdemical的compareTo方法


13、如何实现MySQL异构数据同步？
    阿里Canal + MQ。主要作用：数据监听 + 解耦。
    canal原理：










    整体方案：










14、工厂模式?
    目的：实现调用者和创建者的解耦，调用者无需了解创建细节（比如相关参数），只需使用

    核心本质:
        实例化对象不适用new, 用工厂方法代替
        将选择实现类，创建对象统一管理和控制，从而将调用者跟我们的实现类解耦

    三种模式:
        简单工厂模式:
            用来生产同一等级结构中的任何产品(对于增加新的产品，需要扩展已有代码)
        工厂方法模式:
            用来生产同一等级结构中的固定产品(支持增加任意产品)
        抽象工厂模式:
            围绕一个超级工厂创建其他工厂，该超级工厂又被称为其他工厂的工厂

15、建造者模式？
    使用多个简单的对象一步一步构建成一个复杂的对象，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
    指挥者通过指挥不同的工人、按不同的顺序建造，可以得到不同的产品。相比工厂模式的生产零件，建造者模式更像汽车的组装工厂。
    允许用户只通过指定复杂对象的类型和内容就可以构建它们，不需要知道内部的具体构建细节
    何时使用：一些基本部件不会变，而其组合经常变化的时候。

    核心组成：
        1Builder：抽象建造者，定义多个通用方法和构建方法
        2ConcreteBuilder：具体建造者，可以有多个
        3Director：指挥者，控制整个组合过程，将需求交给建造者，由建造者去创建对象
        4Product：产品角色

16、桥接模式？
    桥接模式提高了系统的可扩展性，在不同的维度中任意扩展一个维度，都不需要修改原系统，负责开闭原则。
    就像一座桥，把两个有独立变化的维度组合起来。
    例子：JDBC的驱动程序、JAVA虚拟机实现了平台的无关性。









17、单一索引和联合索引优先使用哪个？
    当创建**(a,b,c)联合索引时，相当于创建了(a)单列索引**，(a,b)联合索引以及**(a,b,c)联合索引**
    复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。
        如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。
    所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；
        仅对后面的任意列执行搜索时，复合索引则没有用处。

    多个单列索引在多条件查询时优化器会选择最优索引策略，可能只用一个索引，也可能将多个索引全用上！
        但多个单列索引底层会建立多个B+索引树，比较占用空间，也会浪费一定插入修改效率，故如果只有多条件联合查询时最好建联合索引！

18、什么是跨域问题？Springboot中关于跨域问题的解决方法？
    URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口全部相同，则表示他们同源。
        否则，只要协议、域名、端口有任何一个不同，就是跨域。

    在Spring Boot 2.X应用程序中可以使用注解@CrossOrigin，也可以通过使用WebMvcConfigurer对象来定义全局CORS配置。
        1、可以通过实现WebMvcConfigurer接口，然后重写addCorsMappings方法解决跨域问题。
        2、在Controller或者其中业务方法上加上注解@CrossOrigin(origins = "http://localhost:8080");

19、各种MQ优缺点？














20、Redis的使用场景？
    1、热点数据的缓存
    由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，
        我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。

    2、限时业务的运用
    redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

    3、计数器相关问题
      redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、
      具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

    4、排行榜相关问题
    关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的ZSet进行热点数据的排序。

    5、分布式锁
    这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0，
        因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先通过setnx设置一个lock，如果成功设置则执行，
        如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，防止死锁的出现。

    6、分布式的集中存储
    分布式session、分布式id的集中存储之地。



