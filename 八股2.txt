1、多级缓存架构？








    客户端缓存（静态资源）：
            在浏览器层面主要缓存css，js，字体等静态资       源文件
            例如：百度的图标，服务器在响应头中设置expires，浏览器在该段时间将图片以文件缓存在本地，客户端再次访问会看到
                from disk cache的提示，浏览器不再请求服务器，而是直接在本地取图片。
            可以很大程度上缓解浏览器重复请求静态资源的带宽损耗，客户端只需要缓存文件就可以。
    应用层缓存（静态资源）：
            CDN内容分发网络，是互联网静态资源分发的主要技术手段，是广域的互联网应用的基础设施，有效解决了带宽集中占用、资源分发的问题。
            CDN的核心技术是智能DNS。






            例如：大量上海用户访问北京资源。
            但是投入较高，可以租用阿里云、腾讯云、华为云提供的CDN服务，进行租用。

            对于企业级应用，工作人员往往分布在指定的工作区域，或相对固定的场所，再加上并发度并不是很高，
                也就没必要去部署CDN这样重量级的解决方案，可以在架构部署Nginx，利用其自带的静态资源缓存的能力和压缩的功能，
                就可以胜任绝大多数企业级应用场景。Nigix实际是在本地通过一个个目录的方式组织。

    服务层缓存（缓存后端接口查出的数据）：
            进程内缓存：应用中开辟内存空间，进程在运行中载入这块内存，通过本地内存的低延迟，高吞吐特性来提高程序的访问速度（ehCache）
            进程外缓存：分布式缓存（redis），集中缓存。

            先进到远、由快到慢的访问缓存。网络是不确定的，同时访问也是有上限的，所以不能上来就找Redis。
            要在应用端要设计多级应用缓存，通过进程内缓存和进程外缓存结合分摊压力。先看进程内缓存，再看进程外缓存，都查不到再去db，然后写回缓存。

            因为引入多级缓存，要考虑分布式缓存数据一致性问题，此时可以通过MQ主动推送给别的服务实例变更的数据。各实例收到后先删除本地缓存，再重新创建，以保存各实例的数据一致。

2、何时采用多级缓存架构？






3、MySqL集群模式与应用场景
    单库模式：






    读写分离模式：






    分库分表（分片）模式：








        分片算法：




    互联网主流MYsql集群架构：







4、为什么要垂直分表？何时进行垂直分表？
    innodb在1.0以后引入了压缩页，在跨页上解压缩和压缩的执行效率不高，所以表在设计的时候，要尽可能保证每一页内尽可能的多存储一些行数据。
    通过将重要字段剥离，让一页能容纳更多的行，进而缩小数据扫描的页范围，减少跨页检索，检索效率变高。

    数据总量很大且字段超过20，且包含了超长的varchar，CLOB，BLOB。

    主表中主要存放：查询（skuid，商户id）、排序时需要的字段（品牌编号）、高频访问的小字段（商品名称、价格）。
    从表中需要存放：低频访问字段、大字段（图文详情、图片BLOB）

5、为什么在大表严禁使用自增主键？
    在分布式下有严重的问题。
    1、每个分片能承载多少数据，只能靠猜，可能会产生比较大的浪费，不能在运行期间动态扩展的
    2、因为自增主键是在数据库层面生成自增的序列，那么数据库集群必须按主键范围分片（不能hash分片）
    3、范围分片会导致“尾部热点”效应。所有的操作都在一个热点分片上集中处理，该分片的数据库压力会非常大，而其他分片的数据库却没什么压力。

6、为什么不能使用uuid作为主键？
    1、128位，比起整形、长整形浪费空间。
    2、因为无序，作为主键会产生大量的索引重排（可见part1 -51）

7、简介雪花算法SnowFlake？
    有序，且每个机器上序列唯一。






    但是雪花算法要注意时间回拨的问题。但是平常基本不会去时间回拨。
8、布隆过滤器原理？
    二进制数组+n个hash函数。
    在数组中通过hash函数将有效数据所映射的n个位置为1。

    检验数据时，如果全部为1，则代表可能含有该数据。如果出现0，则代表肯定不含此数据。使用的时候只需maven引入redission，其中集成了bloomFilter。

    问题：商品删除了该怎么办？
        布隆过滤器因为某一位二进制可能被多个编号hash映射，因此布隆过滤器无法直接处理删除数据的情况。
        方案1、定时异步重建布隆过滤器（例如每4小时）
        方案2、计数bloomFilter

9、阿里开发规范解读：为啥禁用外键约束？
    表的外键是另一表的主键
    1、额外的数据一致性校验查询，会去另一张表查是否唯一等。
    2、并发问题：外键约束会在主表启用行级锁（共享锁），主表写入或者更新时（开启独占锁），若独占锁一直不释放，详情表会一直阻塞状态。从外界来看，
        所有详情表的写操作，都会因为主表的锁定进入阻塞，可能会导致大量的线程积压，甚至造成系统延迟，崩溃。
    3、级联删除：多层级联删除会让数据变的不可控。禁用是为了数据健壮和可追溯。
    4、数据耦合：数据库层面数据关系产生耦合，数据迁移维护困难，例如：数据多了，将数据源迁移，迁移至大数据库HBASE上，主外键无意义，需要去掉，那么以前程序里未校验的代码可能就出现问题。

10、为什么开发要禁用数据库IP直连？
    会造成两个模块之间强耦合。更换IP时费劲。
    解决：
        1、引入内部DNS：





        2、注册中心：





11、JDBC连接数据库的步骤？
    JDBC连接数据库可以概括为6步，分别是加载JDBC驱动、建立数据库连接、创建一个语句对象、执行一个查询、处理结果集和关闭数据库连接。
    1、加载JDBC驱动
        使用java反射机制中的方法forName()进行加载，如：Class.forName(“com.mysql.jdbc.Driver”);
    2、建立数据库连接
        驱动管理类DriverManager使用特定的驱动程序，通过getConnection(String url)方法建与某个特定数据库的连接。每个JDBC驱动都对应一个URL地址用于自我标识
    3、创建一个语句对象
        创建一个语句对象则需要调用接口java.sql.Connection中的createStatement()方法创建Statement类的语句对象，
        通过创建一个语句对象则可以发送SQL语句到数据库准备执行相应的操作。
    4、执行SQL语句
        将SQL语句发送到数据库之后，根据发送的SQL语句确定执行executeQuery()方法或executeUpdate()方法。
    5、处理结果集
        如果需要从返回的结果集中获取数据，那么可以通过结果集对象调用ResultSet接口的getXXX()方法进行获取。
    6. 关闭数据库连接
        结果集处理完成之后，为了释放资源需要在finally语句块中首先关闭语句对象，再关闭数据库连接，如：
        stmt.close();      //关闭语句对象。
        conn.close();     //关闭数据库连接。

12、浮点数运算
    用BigDecimal
    public class Test {
    public static void main(String[] args) {
        System.out.println((new BigDecimal("2.0")).subtract(new BigDecimal("1.9")).doubleValue());
        }
    }

    api：
        1、BigDecimal(T)
        2、add(BigDecimal) BigDecimal对象中的值相加，返回BigDecimal对象
        3、subtract(BigDecimal) BigDecimal对象中的值相减，返回BigDecimal对象
        4、multiply(BigDecimal) BigDecimal对象中的值相乘，返回BigDecimal对象
        5、divide(BigDecimal) BigDecimal对象中的值相除，返回BigDecimal对象
        6、doubleValue() 将BigDecimal对象中的值转换成双精度数
        7、intValue() 将BigDecimal对象中的值转换成整数
        8、int a = bigdemical.compareTo(bigdemical2) java中对BigDecimal比较大小一般用的是bigdemical的compareTo方法


13、如何实现MySQL异构数据同步？
    阿里Canal + MQ。主要作用：数据监听 + 解耦。
    canal原理：










    整体方案：










14、工厂模式?
    目的：实现调用者和创建者的解耦，调用者无需了解创建细节（比如相关参数），只需使用

    核心本质:
        实例化对象不适用new, 用工厂方法代替
        将选择实现类，创建对象统一管理和控制，从而将调用者跟我们的实现类解耦

    三种模式:
        简单工厂模式:
            用来生产同一等级结构中的任何产品(对于增加新的产品，需要扩展已有代码)
        工厂方法模式:
            用来生产同一等级结构中的固定产品(支持增加任意产品)
        抽象工厂模式:
            围绕一个超级工厂创建其他工厂，该超级工厂又被称为其他工厂的工厂

15、建造者模式？
    使用多个简单的对象一步一步构建成一个复杂的对象，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
    指挥者通过指挥不同的工人、按不同的顺序建造，可以得到不同的产品。相比工厂模式的生产零件，建造者模式更像汽车的组装工厂。
    允许用户只通过指定复杂对象的类型和内容就可以构建它们，不需要知道内部的具体构建细节
    何时使用：一些基本部件不会变，而其组合经常变化的时候。

    核心组成：
        1Builder：抽象建造者，定义多个通用方法和构建方法
        2ConcreteBuilder：具体建造者，可以有多个
        3Director：指挥者，控制整个组合过程，将需求交给建造者，由建造者去创建对象
        4Product：产品角色

16、桥接模式？
    桥接模式提高了系统的可扩展性，在不同的维度中任意扩展一个维度，都不需要修改原系统，负责开闭原则。
    就像一座桥，把两个有独立变化的维度组合起来。
    例子：JDBC的驱动程序、JAVA虚拟机实现了平台的无关性。









17、单一索引和联合索引优先使用哪个？
    当创建**(a,b,c)联合索引时，相当于创建了(a)单列索引**，(a,b)联合索引以及**(a,b,c)联合索引**
    复合索引的结构与电话簿类似，人名由姓和名构成，电话簿首先按姓氏对进行排序，然后按名字对有相同姓氏的人进行排序。
        如果您知道姓，电话簿将非常有用；如果您知道姓和名，电话簿则更为有用，但如果您只知道名不姓，电话簿将没有用处。
    所以说创建复合索引时，应该仔细考虑列的顺序。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；
        仅对后面的任意列执行搜索时，复合索引则没有用处。

    多个单列索引在多条件查询时优化器会选择最优索引策略，可能只用一个索引，也可能将多个索引全用上！
        但多个单列索引底层会建立多个B+索引树，比较占用空间，也会浪费一定插入修改效率，故如果只有多条件联合查询时最好建联合索引！

18、什么是跨域问题？Springboot中关于跨域问题的解决方法？
    URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口全部相同，则表示他们同源。
        否则，只要协议、域名、端口有任何一个不同，就是跨域。

    在Spring Boot 2.X应用程序中可以使用注解@CrossOrigin，也可以通过使用WebMvcConfigurer对象来定义全局CORS配置。
        1、可以通过实现WebMvcConfigurer接口，然后重写addCorsMappings方法解决跨域问题。
        2、在Controller或者其中业务方法上加上注解@CrossOrigin(origins = "http://localhost:8080");

19、各种MQ优缺点？














20、Redis的使用场景？
    1、热点数据的缓存
    由于redis访问速度块、支持的数据类型比较丰富，所以redis很适合用来存储热点数据，另外结合expire，
        我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。

    2、限时业务的运用
    redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

    3、计数器相关问题
      redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、
      具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

    4、排行榜相关问题
    关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的ZSet进行热点数据的排序。

    5、分布式锁
    这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0，
        因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先通过setnx设置一个lock，如果成功设置则执行，
        如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，防止死锁的出现。

    6、分布式的集中存储
    分布式session、分布式id的集中存储之地。

21、服务器响应比较慢，接口慢？你怎么排查，或者列出你认为可能出现的问题点？
    第一步，检查网络
        ping命令检查网络域名解析是否正常，ping服务器的延迟是否过大，如果过大可以检查Ip是否冲突，或者交换机网线是否正常插好，
        通过nmon还可以查看网络流量，一般用的千兆交换机理论速率是1000/8=125MB每秒，但是这理论峰值一般都无法达到，
        所以如果网络流量达到了80~100MB每秒则可以判定瓶颈在交换机上，也可以用telnet来查看端口访问是否正常。
        通过这些方式，首先排除网络可能出现的问题

    第二步，检查服务器内存
        如果请求响应速度慢，一般跟内存关联比较大，通过free -m, vmstat 1，nmon工具等方式判断内存资源是否紧缺

    第三步，查看CPU负载
        可以通过sar、vmstat、top、nmon等工具或命令判断cpu是否过载，如果没有问题那就进行第四步

    第四步，检查磁盘IO
        可以通过iostat 1、vmstat 、nmon等命令检查磁盘的读写，如果没有问题，linux系统自身的性能问题基本排除

    第五步，抓取进程堆栈信息
        通过jstack -l pid | tee -a out.log 将pid的堆栈信息抓取出来，放到out.log的文件中分析，看是在java进程的哪一步耗时较大，然后针对那部分代码进行优化

    第六步、如果单进程没问题、思考点：
        1死锁、资源抢占
        2网络攻击
        3增加CDN、多级缓存
        4数据量过大，使用ES搜索

22、JVM调优介绍
    1查看正在运行中jvm参数是否开启或其值：
        jps :查看后台进程，可以得到进程编号
        jinfo -flag :配置项 PID 查看运行的java程序的各种信息
        jinfo -flags PID :查看所有配置项
        例：命令行（jinfo -flag PrintGCDetails PID） 输出-> -XX:+PrintGCDetails

    2查看所有配置项初始默认值、配置项修改更新值、常用配置：
        java -XX:+PrintFlagsInitial
        java -XX:+PrintFlagsFinal
        java -XX:+PrintCommandLineFlags

    3
    标配参数：
        -version 、 -help
    X参数：
        -Xint解释执行 、-Xcomp编译执行 、 -Xmixed混合模式（先编译后执行）
    XX参数：
        布尔类型：
            -XX:+PrintGCDetails 打印垃圾回收细节
            -XX:+UseSerialGC
        KV类型：
            -Xms <==> -XX:InitialHeapSize=8372
            -Xmx <==> -XX:MaxHeapSize=1024
            -Xss <==> -XX:ThreadStackSize=1024
            -Xmn <==> 设置年轻代大小，一般不调
            -XX:MetaspaceSize=1024m，默认20M左右
            -XX:SurvivorRation 设置新生代中eden比例，一般不调
            -XX:NewRatio 设置老年代的比例
            -XX:MaxTenuringThreshold=15 最大新生区的年龄，一般不调

    补充：1、默认最大堆内存是物理内存的1/4
        2、初始堆内存是物理内存的1/64
        3、新生代一般是堆大小1/3，老年代一般是堆大小2/3
        4、新生代中eden:S0:S1默认8:1:1
        5、MaxTenuringThreshold 范围0~15

23、反射的应用场景及优缺点？
    反射常见的应用场景这里介绍3个：
        Spring 实例化对象：当程序启动时，Spring 会读取配置文件applicationContext.xml并解析出里面所有的<bean>标签实例化到IOC容器中。
        反射 + 工厂模式：通过反射消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，反射可以使得程序更加健壮。
        JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的驱动类时用到反射加载驱动类

    反射的优点：
        增加程序的灵活性：面对需求变更时，可以灵活地实例化不同对象。例如通过传入参数param决定使用哪一种类。
    缺点：
        破坏类的封装性：可以强制访问 private 修饰的信息
        性能损耗：反射相比直接实例化对象、调用方法、访问变量，中间需要非常多的检查步骤和解析步骤，JVM无法对它们优化。

24、创建进程和线程，有哪些系统调用可以用？
    在Linux中主要提供了fork、vfork、clone三个进程创建方法。

    fork创建一个进程时，子进程只是完全复制父进程的资源，复制出来的子进程有自己的task_struct结构和pid,但却复制父进程其它所有的资源。
    vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。
    clone()是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，
        具体要复制哪些资源给子进程，由参数列表中的clone_flags来决定。

    系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，clone()是选择复制。

25、内核或者CPU怎么把你的逻辑地址转化为物理地址？
    Linux内核里把线性地址转换成物理地址是通过页表映射来实现的。页表映射具体还可以分为二级页表、三级页表等。
    页表记录了逻辑页与物理页帧的对应关系，实现从页号到物理块号的地址映射。然后cpu通过物理基地址和页内偏移即可得到物理地址。

26、MMU是什么？TLB是什么？
    MMU
        1）将线性地址映射为物理地址
        2）提供硬件机制的内存访问授权（把不同的进程映射到独立的物理地址）
    TLB
        转译后备缓冲器，也被翻译为页表缓存、转址旁路缓存，为CPU的一种缓存，由存储器管理单元用于改进虚拟地址到物理地址的转译速度

27、操作系统里的I/O模型？
    阻塞IO、非阻塞IO、 IO多路复用、信号驱动式IO、异步IO。

28、SELECT、POLL、EPOLL是NIO还是BIO的模型？是同步调用还是异步调用？
    select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），
    能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，
    也就是说这个读写过程是阻塞的（可能通过while循环来检测内核将数据准备的怎么样了， 而不是属于内核的一种通知用户态机制），
    仍然需要read、write去读写数据。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。
    即异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

29、请求重传ARQ分类？
    传统自动重传请求分成为三种，即停等式(stop-and-wait）ARQ，回退n帧（go-back-n）ARQ，以及选择性重传（selective repeat）ARQ。
    后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为连续ARQ协议。
    三者的区别在于对于出错的数据报文的处理机制不同。三种ARQ协议中，复杂性递增，效率也递增。

    停等式ARQ：
        在停等式ARQ中，数据报文发送完成之后，发送方等待接收方的状态报告，如果状态报告报文发送成功，发送后续的数据报文，否则重传该报文。
        发送窗口和接收窗口大小均为1，发送方每发送一帧之后就必须停下来等待接收方的确认返回，仅当接收方确认正确接收后再继续发送下一帧。
        该方法所需要的缓冲存储空间最小，缺点是信道效率很低。

    回退n帧的ARQ
        发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么从那个发生错误的帧开始及其之后所有的帧全部再重新发送。

    选择性重传ARQ
        发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么发信侧将只重新发送那个发生错误的帧。

30、请求重传报文的是发送端还是接收端?
    当数据包没有成功被接收端接收时，接收端不发送ACK包，发送端将继续等待一段时间并重新发送数据包.直到接收到接收端发来的ACK。

31、TCP连接的SOCKET编程，会用到哪些系统调用和函数？
    socket（）：创建套接字。
    bind（）：指定本地地址。一旦创建了一个套接字，服务器就必须使用bind（）系统调用为套接字建立一个本地地址。
    connect（）：将套接字连接到目的地址。初始创建的套接字并未与任何外地目的地址关联。
        客户机可以调用connect（）为套接字绑定一个永久的目的地址，将它置于已连接状态。
    listen（）：设置等待连接状态。listen函数是用来设置监听连接的句柄和队列，当listen函数执行完成以后，服务端就已经可以接受客户端来的新连接了，
        新连接完成以后listen会把客户端的ip，port和连接句柄放在监听队列里面，等待accept函数来取，如果监听队列满了，listen会拒绝新来的连接。
    accept（）：接受连接请求。然后，服务器调用accept进入等待状态，直到到达一个连接请求。
    send（）/recv（）和sendto（）/recvfrom（）：发送和接收数据 。
    closesocket（）：关闭套接字。

    系统调用：
        sock_create函数：创建socket
        sock_map_fd函数：将file文件结构和fd文件描述符关联，同时将上一步返回的socket也一起绑定

32、静态代理？动态代理？
    一：静态代理是由程序员创建生成代理类，再对其编译，在程序运行之前，代理类.class文件就已经被创建了。
    二：动态代理是在程序运行时通过反射机制动态创建代理对象。

33、上亿的表插入怎么处理？
    插入速度不快：
    1、分表可以通过时间或者其他口径进行切片，原来有个项目中，有个大表是保存员工发送的消息记录，每年一亿条左右，5万员工，按年切片成表，
        每年的消息记录创建一个历史表，索引设计得当，查询速度满足要求，都保存在一台服务器上的一个mysql库运行多年。

    插入速度很快：
    1、如果你的表建了索引，除了主索引其他一定要先删掉，否则插入速度会越来越慢。数据插入完成后再建索引，重建索引也会花不少时间
    2、首先是分表+一致性hash策略，每个表的数据最好控制在百万级，
        是否要拆分服务器，这个看你的情况，如果负载很高，就得分库，然后把不同的库放到不同的服务器上了。
    3、走大数据方案，HBASE、HIVE

34、慢SQL怎么处理？
    （1）索引没起作用的情况
        MYSQL8.0
        EXPLAIN
            type 出现 ALL 或者 index 的；
            possible_keys 出现过多（待选）索引；
            key 为 NULL 的（没走索引）；
            rows 过多，或者几乎是全表的记录数的；
        各种使用不当的情况。
    （2）优化数据库结构
        1. 垂直分表，将字段很多的表分解成多个表  2. 增加字典表，防止跨节点join
    （3）分解关联查询
        将一个大的查询分解为多个小查询，在service层组合。
    （4）优化LIMIT分页
        先查询出90000条数据对应的主键id的值，然后直接通过该id的值直接查询该id后面的数据。
        select id,title from collect limit 90000,10;
        优化为：select id,title from collect where id>=(select id from collect order by id limit 90000,1) limit 10
    （5）CDN服务
        服务器比较远


35、linux查看端口占用情况
    1、lsof -i:端口号 用于查看某一端口的占用情况
        比如查看8000端口使用情况，lsof -i:8000

36、MQ核心组件
    ActiveMQ 使用时包含的基本组件各与 JMS 是相同的：

        Broker，消息代理，表示消息队列服务器实体，接受客户端连接，提供消息通信的核心服务。
        Producer，消息生产者，业务的发起方，负责生产消息并传输给 Broker 。
        Consumer，消息消费者，业务的处理方，负责从 Broker 获取消息并进行业务逻辑处理。
        exchanger，交换机。
        Queue，队列，点对点模式下特定生产者向特定队列发送消息，消费者订阅特定队列接收消息并进行业务逻辑处理。
        Message，消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务 数据，实现消息的传输。
        Topic，主题，发布订阅模式下的消息统一汇集地，不同生产者向 Topic 发送消息，由 Broker 分发到不同的订阅者，实现消息的广播。

37、Redis是线程安全的吗？如何保证线程安全？
    1、Redis中本身就是单线程的能够保证线程安全问题。redis是单线程运行，所以多个redis命令是一个一个执行，所以是线程安全的.
        Redis实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题。

    2、不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁。
        分开的两个redis命令，对于【应用】不是线程安全的，因为这两个redis命令之间会有其他命令，就像java线程不安全的i++操作，
        这个两个redis命令没有事务管理 。

    3. 可以用RPOPLPUSH或者INCR , 或者lua脚本，实现多个redis操作合为一个命令，这样就对【应用】线程安全了

38、MySQL高可用架构方案？
    MHA:















39、Redis的Sentinel高可用架构？























40、阿里巴巴Seata分布式事务解决方案？

















41、分布式任务调度？



    定时任务随着技术发展，从单线程调度到多线程调度，从单机部署到集群部署，从独立执行到多任务协同执行。

    第一阶段
    单线程调度，在Java1.5之前，基于线程的等待(sleep或wait)机制定时执行，需要开发者实现调度逻辑，单个线程(Thread)处理单个任务有些浪费，
        但是一个线程(Timer)处理多个任务容易因为某个任务繁忙导致其他任务阻塞。

    第二阶段
    线程池调度，在Java1.5开始提供ScheduledExecutorService调度线程池，调度线程池支持固定的延时和固定间隔模式，
        对于需要在某天或者某月的时间点执行就不大方便，需要计算时间间隔，转换成启动延时和固定间隔，处理起来比较麻烦。

    第三阶段
    Spring任务调度，Spring简化了任务调度，通过@Scheduled注解支持将某个Bean的方法定时执行，除了支持固定延时和固定间隔模式外，
        还支持cron表达式，使得定时任务的开发变得极其简单。 加注解@Scheduled(cron = "0/20 * * * * *")

    第四阶段
    Quartz任务调度，在任务服务集群部署下，Quartz通过数据库锁，实现任务的调度并发控制，避免同一个任务同时执行的情况。
        Quartz通过Scheduler提供了任务调度API，开发可以基于此开发自己的任务调度管理平台。

    第五阶段
    分布式任务平台，提供一个统一的平台，无需再去做和调度相关的开发，业务系统只需要实现具体的任务逻辑，自动注册到任务调度平台，
        在上面进行相关的配置就完成了定时任务的开发。

42、java和C++有什么相同点和不同点吗
    Java语言不需要程序对内存进行分配和回收。Java丢弃了C++ 中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。
    特别地，Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题。

43、JDK11和JDK15的新特性？
    JDK11：
    1Local Var
        在Lambda表达式中，可以使用var关键字来标识变量，变量类型由编译器自行推断。
    2HttpClient
        长期以来，如果要访问Http资源，JDK的标准库中只有一个HttpURLConnection，这个古老的API使用非常麻烦，而且已经不适用于最新的HTTP协议。
        JDK11的新的HttpClient支持HTTP/2和WebSocket，并且可以使用异步接口：
    3List API
        对于List接口，新增了一个of(T...)接口，用于快速创建List对象：List<String> list = List.of("Java", "Python", "Ruby");

    JDK15：
    1封闭类sealed
         可以是封闭类和或者封闭接口，用来增强 Java 编程语言，防止其他类或接口扩展或实现它们。
         有了这个特性，意味着以后不是你想继承就继承，想实现就实现了，你得经过允许permits才行。
         例子：public abstract sealed class Student
                permits ZhangSan, LiSi, ZhaoLiu {
                ...

            }

    2准备禁用和废除偏向锁
        在 JDK 15 中，默认情况下禁用偏向锁（Biased Locking），并弃用所有相关的命令行选项。
        后面再确定是否需要继续支持偏向锁，国为维护这种锁同步优化的成本太高了。

    3ZGC垃圾回收器 功能转正
        ZGC是一个可伸缩、低延迟的垃圾回收器。默认仍然是 G1。

44.CMS会产生什么问题？
    内存碎片（原因是采用了标记-清除算法）
    对 CPU 资源敏感（原因是并发时和用户线程一起抢占 CPU）
    浮动垃圾：在并发标记阶段产生了新垃圾不会被及时回收，而是只能等到下一次GC

45.CMS中产生的碎片有什么方法解决吗?
    CMS是一款基于“标记-清除”算法实现的收集器，如果读者对前面这部分介绍还有印象的话，就可能想到这意味着收集结束时会有大量空间碎片产生。
        空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，
        而不得不提前触发一次Full GC的情况。

    虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBefore-Compaction（此参数从JDK 9开始废弃），
        这个参数的作用是要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，
        下一次进入Full GC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）。

46、Redis集群的全量同步和增量同步是通过什么实现的？
    全量同步： master执行bgsave生成rdb数据快照发送给Slave
    增量同步：
        从服务器 每秒钟 向从服务器发送REPLCONF ACK <replication_offset>命令来做心跳检测，以及告诉主节点自己的复制偏移量。
        主服务器若发现从服务器的复制偏移量小于自己的，根据从服务器发过来的offset，在复制积压缓冲区中找到offset之后的数据，并将其发给从节点执行就可以了。

47、CurrentHashMap的size函数？
    在实际的项目过程中，我们通常需要获取集合类的长度， 那么计算 ConcurrentHashMap 的元素大小就是一个有趣的问题，因为他是并发操作的，
        就是在你计算 size 的时候，它还在并发的插入数据，可能会导致你计算出来的 size 和你实际的 size 有差距。

    众所周知，concurrenthashmap有很多个segments，首先遍历segments将每个segment的count加起来作为整个concurrenthashMap的size。
        如果没有并发的情况下这自然就可以了，但这是多线程的，如果前脚统计完后脚有变化了，这就不准确了，源码中引入了modCount和两次比较来实现size的确认。
    1.进行第一遍遍历segments数组，将每个segemnt的count加起来作为总数，期间把每个segment的modCount加起来sum作为结果是否被修改的判断依据。
        这里需要提一下modCount，这个是当segment有任何操作都会进行一次增量操作，代表的是对Segment中元素的数量造成影响的操作的次数，
        这个值只增不减！！只增不减很重要，这样就不会出现一个segment+1，导致modcount+1,而另一个segment-1，即modcount-1 ,从而在统计所有的时候modcount没有变化。
    2.size操作就是遍历了两次所有的Segments，每次记录Segment的modCount值，然后将两次的modCount进行比较，如果相同，则表示期间没有发生过写入操作，
        就将原先遍历的结果返回，如果不相同，则把这个过程再重复做一次，如果再不相同，则就需要将所有的Segment都锁住，然后一个一个遍历了。
    3.而之所以之所以要先不加锁进行判断，道理很明显，就是不希望因为size操作获取这么多锁，因为获取锁不光占用资源，
        也会影响其他线程对ConcurrentHash的使用，影响并发情况下程序执行的效率。使用锁要谨慎！

    总结：在 JDK1.7 中，
        第一种方案他会使用不加锁的模式去尝试多次计算 ConcurrentHashMap 的 size，最多三次，
            比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的。
        第二种方案是如果第一种方案不符合，他就会给每个 Segment 加上锁，然后计算 ConcurrentHashMap 的 size 返回。

            JDK1.8 size
            是通过对 baseCount 和 counterCell 进行 CAS 计算，最终通过 baseCount 和 遍历 CounterCell 数组得出 size。


48.newCachedThreadPool的实现原理？
    newCachedThreadPool创建一个可缓存线程池，用于处理大量短时间工作任务的线程池。
        1）核心线程数为0；
        2）最大线程数为Interger.MAX_VALUE，即0x7fffffff（2147483647）
        3）线程空闲时长为60秒，如果空闲超过60秒，则线程将被终止，并移出缓存。
    该线程池，使用J.U.C的SynchronousQueue阻塞队列，该队列具有以下几个特性：
        1）SynchronousQueue没有容量。与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。
            每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。
        2）因为没有容量，所以对应 peek, contains, clear, isEmpty ... 等方法其实是无效的。
            例如clear是不执行任何操作的，contains始终返回false,peek始终返回null。

49.红黑树和平衡二叉树的区别？跳表的查找时间复杂度？
    红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。
        平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。

    最高级索引 h 满足 2 = n/2^h，即 h = log2n - 1，最高级索引 h 为索引层的高度加上原始数据一层，跳表的总高度 h = log2n。所以查找的时间复杂度是常数*log2n
50.新生代转换为老年代有几种情况？
    1.Eden区满时，进行Minor GC
        当Eden和一个Survivor区中依然存活的对象无法放入到Survivor中，则通过分配担保机制提前转移到老年代中。

    2.对象体积太大, 新生代无法容纳
        -XX:PretenureSizeThreshold即对象的大小大于此值, 就会绕过新生代, 直接在老年代分配, 此参数只对Serial及ParNew两款收集器有效。

    3.长期存活的对象将进入老年代
        虚拟机对每个对象定义了一个对象年龄（Age）计数器。当年龄增加到一定的临界值时，就会晋升到老年代中，该临界值由参数：-XX:MaxTenuringThreshold来设置。
            如果对象在Eden出生并在第一次发生MinorGC时仍然存活，并且能够被Survivor中所容纳的话，则该对象会被移动到Survivor中，并且设Age=1；
            以后每经历一次Minor GC，该对象还存活的话Age=Age+1。

    4.动态对象年龄判定
        虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升到老年代，如果在Survivor区中相同年龄（设年龄为age）
            的对象的所有大小之和超过Survivor空间的一半，年龄大于或等于该年龄（age）的对象就可以直接进入老年代，
            无需等到MaxTenuringThreshold中要求的年龄。

51.TCP的TIME_WAIT和CLOSE_WAIT介绍下？如果系统中出现了大量的CLOSE_WAIT怎么排查？
    TIME_WAIT : 2MSL
    CLOSE_WAIT : 服务端收到FIN信号后进入该状态，该状态即为服务端处理完响应逻辑代码的阶段？

    通常，CLOSE_WAIT 状态在服务器停留时间很短，如果你发现大量的 CLOSE_WAIT 状态，那么就意味着被动关闭的一方没有及时发出 FIN 包，一般有如下几种可能：
        1程序问题：如果代码层面忘记了 close 相应的 socket 连接，那么自然不会发出 FIN 包，从而导致 CLOSE_WAIT 累积；
            或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到。
        2响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。
            响应太慢是首要问题，不过换个角度看，也可能是 timeout 设置过小。

52.往redis存对象，使用String好还是Hash结构好，分析优缺点？
    当如下情况时redis的hash类型，底层是用ziplist编码的：
        哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；
        哈希对象保存的键值对数量小于 512 个；
    不满足上述情况时，redis的hash类型，底层编码格式为hashtable。

    如果你的业务类型中对于缓存的读取缓存的场景更多，并且更新缓存不频繁（或者每次更新都更新json数据中的大多数key），那么选择string类型作为存储方式会比较好。
    如果你的业务类型中对于缓存的更新比较频繁（特别是每次只更新少数几个键）时， 或者我们每次只想取json数据中的少数几个键值时，我们选择hash类型作为我们的存储方式会比较好。.

53.sentinel模式故障转移怎么做到外部无感知？
    故障转移后客户端无法感知将无法保证正常的使用。所以，实现客户端高可用的步骤如下:
        1.客户端获取sentinel节点集合
        2.客户端通过sentinel get-master-addr-by-name master-name这个api来获取对应主节点信息
        3.客户端验证当前获取的“主节点”是真正的主节点，这样的目的是为了防止故障转移期间主节点的变化
        4.客户端保持和sentinel节点集合的联系，即订阅sentinel节点相关频道，时刻获取关于主节点的相关信息

    从上面的模型可以看出，Redis sentinel客户端只有在初始化和切换主节点时需要和sentinel进行通信来获取主节点信息，
        所以在设计客户端时需要将sentinel节点集合考虑成配置（相关节点信息和变化）发现服务。

54.介绍下java线程join方法
    join方法是实现线程同步，可以将原本并行执行的多线程方法变成串行执行的。源码还是比较容易理解的，其实就是调用了现场wait方法实现线程同步的

    join方法的作用是，举个例子，在A线程里调B线程的join方法时，要先B线程执行完成，然后才会继续执行A线程
        上面调join方法是不加参数的，也可以加上参数，比如线程A.join(10)；，就是说线程A执行10s后，继续执行B线程
        注意：join时间参数缺省的情况，默认是0，也就是说join()等同于join(0);0不是表示执行0s，而是表示要A线程执行完成才继续执行B线程的意思。

55.线程池用到哪些阻塞队列?
    线程池	阻塞队列
    FixedThreadPool	                LinkedBlockingQueue
    SingleThreadExecutor	        LinkedBlockingQueue
    CachedThreadPool	            SynchronousQueue
    ScheduledThreadPool	            DelayedWorkQueue
    SingleThreadScheduledExecutor	DelayedWorkQueue

    LinkedBlockingQueue
        第一种阻塞队列是 LinkedBlockingQueue，它的容量是 Integer.MAX_VALUE，是一个非常大的值，可以认为是无界队列。
        FixedThreadPool 和 SingleThreadExecutor 线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，
            这时就需要 LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务。

    SynchronousQueue
        第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer.MAX_VALUE，可以理解为线程数是可以无限扩展的。
        CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，FixedThreadPool 的情况是阻塞队列的容量是无限的，而这里 CachedThreadPool 是线程数可以无限扩展，
            所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。

        我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就需要注意设置最大线程数要尽可能大一些，
            以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。

    DelayedWorkQueue
        第三种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，
            这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。

        DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。
            之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。

56.线程知识中Future 的作用？
    简单来说就是利用线程达到异步的效果，同时还可以获取子线程的返回值。
        我们可以把运算的过程放到子线程去执行，再通过 Future 去获取到计算结果。这样一来就可以把整个程序的运行效率提高，是一种异步的思想。

    FutureTask实现了两个接口，Runnable和Future，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值
    典型用法是，把 Callable 实例当作 FutureTask 构造函数的参数，生成 FutureTask 的对象，
        然后把这个对象当作一个 Runnable 对象，放到线程池中或另起线程去执行，最后还可以通过 FutureTask 获取任务执行的结果

57.cpu如何寻址？
    处理器采用多级页表来进行多次查找最终找到真正的物理地址。
        由于页表是存放在内存中的，使用一级页表进行地址转换时，每次读/写数据需要访问两次内存，第一次访问一级页表获得物理地址，第二次才是真正的读/写数据；
        使用两级页表时，每次读/写数据需要访问三次内存，访问两次页表（一级页表和二级页表）获得物理地址，第三次才是真正的读/写数据。
    拿处理器访问两级页表举例说明，当处理器拿到一个需要访问内存的虚拟地址，MMU首先访问TLB Cache（近期页表的缓存），如果TLB Cache中含有能转换这个虚拟地址的描述符，
        则直接利用此描述符进行地址转换和权限检查；否则MMU访问页表（页表是在主存中）找到描述符后再进行地址转换和权限检查，并将这个描述符填入TLB Cache中，
        下次再使用这个虚拟地址时就可以直接使用TLB Cache中的地址描述符了。

58.为什么要三次握手?
    为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。
        三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。
        如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。

    同时这样可以防止已失效的连接请求又传送到服务器端，因而产生错误。

59.Redis的Cluster集群模式？
    结构：                                            分配策略：







    特点：







    故障转移：







60.说说Web高可用架构？







