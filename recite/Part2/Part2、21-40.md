21、服务器响应比较慢，接口慢？你怎么排查，或者列出你认为可能出现的问题点？
    第一步，检查网络
        ping命令检查网络域名解析是否正常，ping服务器的延迟是否过大，如果过大可以检查Ip是否冲突，或者交换机网线是否正常插好，
        通过nmon还可以查看网络流量，一般用的千兆交换机理论速率是1000/8=125MB每秒，但是这理论峰值一般都无法达到，
        所以如果网络流量达到了80~100MB每秒则可以判定瓶颈在交换机上，也可以用telnet来查看端口访问是否正常。
        通过这些方式，首先排除网络可能出现的问题

    第二步，检查服务器内存
        如果请求响应速度慢，一般跟内存关联比较大，通过free -m, vmstat 1，nmon工具等方式判断内存资源是否紧缺
    
    第三步，查看CPU负载
        可以通过sar、vmstat、top、nmon等工具或命令判断cpu是否过载，如果没有问题那就进行第四步
    
    第四步，检查磁盘IO
        可以通过iostat 1、vmstat 、nmon等命令检查磁盘的读写，如果没有问题，linux系统自身的性能问题基本排除
    
    第五步，抓取进程堆栈信息
        通过jstack -l pid | tee -a out.log 将pid的堆栈信息抓取出来，放到out.log的文件中分析，看是在java进程的哪一步耗时较大，然后针对那部分代码进行优化
    
    第六步、如果单进程没问题、思考点：
        1死锁、资源抢占
        2网络攻击
        3增加CDN、多级缓存
        4数据量过大，使用ES搜索

22、JVM调优介绍
    1查看正在运行中jvm参数是否开启或其值：
        jps :查看后台进程，可以得到进程编号
        jinfo -flag :配置项 PID 查看运行的java程序的各种信息
        jinfo -flags PID :查看所有配置项
        例：命令行（jinfo -flag PrintGCDetails PID） 输出-> -XX:+PrintGCDetails

    2查看所有配置项初始默认值、配置项修改更新值、常用配置：
        java -XX:+PrintFlagsInitial
        java -XX:+PrintFlagsFinal
        java -XX:+PrintCommandLineFlags
    
    3
    标配参数：
        -version 、 -help
    X参数：
        -Xint解释执行 、-Xcomp编译执行 、 -Xmixed混合模式（先编译后执行）
    XX参数：
        布尔类型：
            -XX:+PrintGCDetails 打印垃圾回收细节
            -XX:+UseSerialGC
        KV类型：
            -Xms <==> -XX:InitialHeapSize=8372
            -Xmx <==> -XX:MaxHeapSize=1024
            -Xss <==> -XX:ThreadStackSize=1024
            -Xmn <==> 设置年轻代大小，一般不调
            -XX:MetaspaceSize=1024m，默认20M左右
            -XX:SurvivorRation 设置新生代中eden比例，一般不调
            -XX:NewRatio 设置老年代的比例
            -XX:MaxTenuringThreshold=15 最大新生区的年龄，一般不调
    
    补充：1、默认最大堆内存是物理内存的1/4
        2、初始堆内存是物理内存的1/64
        3、新生代一般是堆大小1/3，老年代一般是堆大小2/3
        4、新生代中eden:S0:S1默认8:1:1
        5、MaxTenuringThreshold 范围0~15

23、反射的应用场景及优缺点？
    反射常见的应用场景这里介绍3个：
        Spring 实例化对象：当程序启动时，Spring 会读取配置文件applicationContext.xml并解析出里面所有的<bean>标签实例化到IOC容器中。
        反射 + 工厂模式：通过反射消除工厂中的多个分支，如果需要生产新的类，无需关注工厂类，工厂类可以应对各种新增的类，反射可以使得程序更加健壮。
        JDBC连接数据库：使用JDBC连接数据库时，指定连接数据库的驱动类时用到反射加载驱动类

    反射的优点：
        增加程序的灵活性：面对需求变更时，可以灵活地实例化不同对象。例如通过传入参数param决定使用哪一种类。
    缺点：
        破坏类的封装性：可以强制访问 private 修饰的信息
        性能损耗：反射相比直接实例化对象、调用方法、访问变量，中间需要非常多的检查步骤和解析步骤，JVM无法对它们优化。

24、创建进程和线程，有哪些系统调用可以用？
    在Linux中主要提供了fork、vfork、clone三个进程创建方法。

    fork创建一个进程时，子进程只是完全复制父进程的资源，复制出来的子进程有自己的task_struct结构和pid,但却复制父进程其它所有的资源。
    vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。
    clone()是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，
        具体要复制哪些资源给子进程，由参数列表中的clone_flags来决定。
    
    系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，clone()是选择复制。

25、内核或者CPU怎么把你的逻辑地址转化为物理地址？
    Linux内核里把线性地址转换成物理地址是通过页表映射来实现的。页表映射具体还可以分为二级页表、三级页表等。
    页表记录了逻辑页与物理页帧的对应关系，实现从页号到物理块号的地址映射。然后cpu通过物理基地址和页内偏移即可得到物理地址。

26、MMU是什么？TLB是什么？
    MMU
        1）将线性地址映射为物理地址
        2）提供硬件机制的内存访问授权（把不同的进程映射到独立的物理地址）
    TLB
        转译后备缓冲器，也被翻译为页表缓存、转址旁路缓存，为CPU的一种缓存，由存储器管理单元用于改进虚拟地址到物理地址的转译速度

27、操作系统里的I/O模型？
    阻塞IO、非阻塞IO、 IO多路复用、信号驱动式IO、异步IO。

28、SELECT、POLL、EPOLL是NIO还是BIO的模型？是同步调用还是异步调用？
    select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），
    能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，
    也就是说这个读写过程是阻塞的（可能通过while循环来检测内核将数据准备的怎么样了， 而不是属于内核的一种通知用户态机制），
    仍然需要read、write去读写数据。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。
    即异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

29、请求重传ARQ分类？
    传统自动重传请求分成为三种，即停等式(stop-and-wait）ARQ，回退n帧（go-back-n）ARQ，以及选择性重传（selective repeat）ARQ。
    后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为连续ARQ协议。
    三者的区别在于对于出错的数据报文的处理机制不同。三种ARQ协议中，复杂性递增，效率也递增。

    停等式ARQ：
        在停等式ARQ中，数据报文发送完成之后，发送方等待接收方的状态报告，如果状态报告报文发送成功，发送后续的数据报文，否则重传该报文。
        发送窗口和接收窗口大小均为1，发送方每发送一帧之后就必须停下来等待接收方的确认返回，仅当接收方确认正确接收后再继续发送下一帧。
        该方法所需要的缓冲存储空间最小，缺点是信道效率很低。
    
    回退n帧的ARQ
        发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么从那个发生错误的帧开始及其之后所有的帧全部再重新发送。
    
    选择性重传ARQ
        发信侧不用等待收信侧的应答，持续的发送多个帧，假如发现已发送的帧中有错误发生，那么发信侧将只重新发送那个发生错误的帧。

30、请求重传报文的是发送端还是接收端?
    当数据包没有成功被接收端接收时，接收端不发送ACK包，发送端将继续等待一段时间并重新发送数据包.直到接收到接收端发来的ACK。

31、TCP连接的SOCKET编程，会用到哪些系统调用和函数？
    socket（）：创建套接字。
    bind（）：指定本地地址。一旦创建了一个套接字，服务器就必须使用bind（）系统调用为套接字建立一个本地地址。
    connect（）：将套接字连接到目的地址。初始创建的套接字并未与任何外地目的地址关联。
        客户机可以调用connect（）为套接字绑定一个永久的目的地址，将它置于已连接状态。
    listen（）：设置等待连接状态。listen函数是用来设置监听连接的句柄和队列，当listen函数执行完成以后，服务端就已经可以接受客户端来的新连接了，
        新连接完成以后listen会把客户端的ip，port和连接句柄放在监听队列里面，等待accept函数来取，如果监听队列满了，listen会拒绝新来的连接。
    accept（）：接受连接请求。然后，服务器调用accept进入等待状态，直到到达一个连接请求。
    send（）/recv（）和sendto（）/recvfrom（）：发送和接收数据 。
    closesocket（）：关闭套接字。

    系统调用：
        sock_create函数：创建socket
        sock_map_fd函数：将file文件结构和fd文件描述符关联，同时将上一步返回的socket也一起绑定

32、静态代理？动态代理？
    一：静态代理是由程序员创建生成代理类，再对其编译，在程序运行之前，代理类.class文件就已经被创建了。
    二：动态代理是在程序运行时通过反射机制动态创建代理对象。

33、上亿的表插入怎么处理？
    插入速度不快：
    1、分表可以通过时间或者其他口径进行切片，原来有个项目中，有个大表是保存员工发送的消息记录，每年一亿条左右，5万员工，按年切片成表，
        每年的消息记录创建一个历史表，索引设计得当，查询速度满足要求，都保存在一台服务器上的一个mysql库运行多年。

    插入速度很快：
    1、如果你的表建了索引，除了主索引其他一定要先删掉，否则插入速度会越来越慢。数据插入完成后再建索引，重建索引也会花不少时间
    2、首先是分表+一致性hash策略，每个表的数据最好控制在百万级，
        是否要拆分服务器，这个看你的情况，如果负载很高，就得分库，然后把不同的库放到不同的服务器上了。
    3、走大数据方案，HBASE、HIVE

34、慢SQL怎么处理？
    （1）索引没起作用的情况
        MYSQL8.0
        EXPLAIN
            type 出现 ALL 或者 index 的；
            possible_keys 出现过多（待选）索引；
            key 为 NULL 的（没走索引）；
            rows 过多，或者几乎是全表的记录数的；
        各种使用不当的情况。
    （2）优化数据库结构
        1. 垂直分表，将字段很多的表分解成多个表  2. 增加字典表，防止跨节点join
    （3）分解关联查询
        将一个大的查询分解为多个小查询，在service层组合。
    （4）优化LIMIT分页
        先查询出90000条数据对应的主键id的值，然后直接通过该id的值直接查询该id后面的数据。
        select id,title from collect limit 90000,10;
        优化为：select id,title from collect where id>=(select id from collect order by id limit 90000,1) limit 10
    （5）CDN服务
        服务器比较远


35、linux查看端口占用情况
    1、lsof -i:端口号 用于查看某一端口的占用情况
        比如查看8000端口使用情况，lsof -i:8000

36、MQ核心组件
    ActiveMQ 使用时包含的基本组件各与 JMS 是相同的：

        Broker，消息代理，表示消息队列服务器实体，接受客户端连接，提供消息通信的核心服务。
        Producer，消息生产者，业务的发起方，负责生产消息并传输给 Broker 。
        Consumer，消息消费者，业务的处理方，负责从 Broker 获取消息并进行业务逻辑处理。
        exchanger，交换机。
        Queue，队列，点对点模式下特定生产者向特定队列发送消息，消费者订阅特定队列接收消息并进行业务逻辑处理。
        Message，消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务 数据，实现消息的传输。
        Topic，主题，发布订阅模式下的消息统一汇集地，不同生产者向 Topic 发送消息，由 Broker 分发到不同的订阅者，实现消息的广播。

37、Redis是线程安全的吗？如何保证线程安全？
    1、Redis中本身就是单线程的能够保证线程安全问题。redis是单线程运行，所以多个redis命令是一个一个执行，所以是线程安全的.
        Redis实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题。

    2、不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁。
        分开的两个redis命令，对于【应用】不是线程安全的，因为这两个redis命令之间会有其他命令，就像java线程不安全的i++操作，
        这个两个redis命令没有事务管理 。
    
    3. 可以用RPOPLPUSH或者INCR , 或者lua脚本，实现多个redis操作合为一个命令，这样就对【应用】线程安全了

38、MySQL高可用架构方案？
    MHA:



























39、Redis的Sentinel高可用架构？



























40、阿里巴巴Seata分布式事务解决方案？

























